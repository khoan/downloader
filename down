#!/usr/bin/env ruby

start = Time.now

require 'rest-core'
require 'clap'

module RestCore
  headers = {}
  args = ::Clap.run ARGV,
    '-H' => ->(v){
      key, value = v.split(': ', 2)
      headers[key] = value
    }

  Down = RestBuilder::Builder.client do
    use Defaults, {playlist_url: args[0], output: args[1], scheme: args[0][/https?:/]}
    use DefaultSite, File.dirname(args[0])
    use DefaultHeaders, headers
    use ErrorHandler  , ->(res){puts "Error: #{res}"}
    use ErrorDetectorHttp
    #use FollowRedirect, 10
  end

  # pool_size should be at least be larger than 4, or it might be very likely to have deadlock
  # setting pool_size to -1 to make blocking requests, without spawning any threads
  Down.pool_size = -1 
  Down.pool_idle_time = 60
end

d = RestCore::Down.new

raise "Missing output file name" unless d.defaults[:output]

output = d.defaults[:output]

list = []
d.get(
  d.defaults[:playlist_url]
).each_line do |url|
  next if url.start_with? '#'

  url = url.chomp
  url = "#{d.defaults[:scheme]}#{url}" if url.start_with? '//'
  response = d.request_full(
    RestCore::REQUEST_METHOD => :head,
    RestCore::REQUEST_PATH => url
  )
  if [301, 302, 303, 307].include? Integer(response[RestCore::RESPONSE_STATUS])
    url = response[RestCore::RESPONSE_HEADERS]['LOCATION']
  end

  path = ".#{output}--#{File.basename(url)}"

  list << {path: path, url: url}
end
list.uniq!

downloaded = 0
puts "downloading #{list.size} parts..."
list.each do |part|
  if File.exist? part[:path]
    downloaded += 1
  else
    d.get(part[:url], {}, headers: {'Origin' => 'null', 'Accept-Encoding' => 'identity'}) do |data|
      downloaded += 1
      IO.write(
        part[:path], data, 0,
        mode: 'w', encoding: data.encoding
      )
      print "\rdownloaded #{downloaded}/#{list.size}"
    end
  end
end
RestCore::Down.wait

puts "assembling parts..."
File.open(output, 'ab') do |t|
  list.each do |part|
    IO.copy_stream(part[:path], t)
  end
end

puts "Took #{Time.now - start}s"
